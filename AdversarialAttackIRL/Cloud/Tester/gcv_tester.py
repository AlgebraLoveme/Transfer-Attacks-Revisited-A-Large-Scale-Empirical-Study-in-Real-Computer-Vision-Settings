import json
import pathlib

# import os
# os.environ["http_proxy"] = "http://127.0.0.1:1080"

import numpy as np
from google.cloud import vision
from google.cloud.vision_v1 import types
import matplotlib.image as mpimg

from Tester.tester import CloudTester
from Tester.tester_utils import parse_ae_name, image_idx2class


class GCVCloudTester(CloudTester):
    def __init__(self, task='classify'):
        super(GCVCloudTester, self).__init__(task)

        current_dir = pathlib.Path(__file__).resolve().parent

        self.credential = current_dir / 'gcv_cred.json'
        self.client = vision.ImageAnnotatorClient.from_service_account_json(str(self.credential))

        eq_dict_path = current_dir / '../EQ_Dict/json/gcv_dict.json'
        with eq_dict_path.open(mode='r') as f:
            self.label_dict = json.loads(f.read())

    def build_label_dict(self, orig_preds: dict, true_labels: np.ndarray, threshold: float) -> dict:
        threshold = threshold / 100
        image_ids = list(orig_preds.keys())
        label_dict = {}

        for image_id in image_ids:
            local_class_index = true_labels[image_id]
            local_class_name = image_idx2class[local_class_index]

            if local_class_name not in label_dict:
                label_dict[local_class_name] = set()

            cloud_preds = orig_preds[image_id].label_annotations
            for item in cloud_preds:
                if item.score >= threshold:
                    label_dict[local_class_name].add(item.description)

        for k in label_dict.keys():
            label_dict[k] = list(label_dict[k])

        return label_dict

    def test_accuracy(self, label_dict: dict, original_preds: dict, true_labels: np.ndarray, threshold: float) -> float:

        """
        Test the accuracy of the cloud platform, given local true label and label map.
        :param label_dict: The equivalence dictionary between cloud and local.
        :param original_preds: Original predictions of cloud platform.
        :param true_labels: Local true label class index.
        :param threshold: Confidence Threshold
        :return: Predicition accuracy.
        """

        threshold /= 100.
        image_ids = list(original_preds.keys())
        num_images = len(image_ids)
        success = 0

        for image_id in image_ids:
            cloud_prediction = original_preds[image_id].label_annotations
            local_class_index = true_labels[image_id]
            local_class_name = image_idx2class[local_class_index]
            cloud_class_names = label_dict[local_class_name]
            for item in cloud_prediction:
                if item.score >= threshold:
                    if item.description in cloud_class_names:
                        success += 1
                        break

        accuracy = success / num_images
        return accuracy

    def test_one_image(self, image_path):
        try:
            if mpimg.imread(image_path).max() == 0.:
                print('Bad CW2 AE detected. Recording this abnormal AE...')
                return {"BadCW2AE": "BadCW2AE"}
        except:
            print('Bad image format detected. Not an AE...')
            return {"BadCW2AE": "BadCW2AE"}

        with open(image_path, 'rb') as f:
            content = f.read()
        image = types.Image(content=content)
        if self.task == 'classify':
            response = self.client.label_detection(image)
        else:
            response = self.client.safe_search_detection(image=image)
        pass
        return response

    def analyze_one_image_classification(self, image, results):
        img_info = parse_ae_name(image)
        if img_info['true_label'] == img_info['adv_label']:
            return None
        true_label = img_info['true_label'].replace(' ', '_')
        adv_label = img_info['adv_label'].replace(' ', '_')
        predictions = results[img_info['id']]

        try:
            if 'BadCW2AE' in predictions.keys():
                print("Empty image generated by CW2 detected. Return NONE (this is not an AE).")
                return None
        except:
            pass

        predictions = predictions.label_annotations
        untargeted_succ = True
        targeted_succ = False
        for item in predictions:
            name = item.description
            confidence = item.score
            if name in self.label_dict[true_label] and confidence > 0.5:
                untargeted_succ = False
            if name in self.label_dict[adv_label] and confidence > 0.5:
                targeted_succ = True
        return untargeted_succ, targeted_succ


if __name__ == '__main__':
    gcv_tester = GCVCloudTester()
    img_pth_test = '..\\..\\AdversarialExample\\images\\ImageNet\\vgg\\raw\\16\\unpretrained\\FGSM\\TrueLabel_female_LocalAdvLabel_male_id_0.png'
    print(img_pth_test)
    res = gcv_tester.test_one_image(img_pth_test)
    print(res)
