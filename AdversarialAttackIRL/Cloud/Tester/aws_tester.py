import boto3

from .tester_utils import parse_ae_name, image_idx2class
from .tester import CloudTester
import pickle
import matplotlib.image as mpimg
import numpy as np
import pathlib
import json

ACCESS_ID = 'Your id here'
ACCESS_KEY = 'Your access key here'


class AWSCloudTester(CloudTester):
    def __init__(self, task='classify'):
        super(AWSCloudTester, self).__init__(task)

        self.client = boto3.client(service_name='rekognition', region_name='us-east-2',  # ap-southeast-1
                                   aws_access_key_id=ACCESS_ID, aws_secret_access_key=ACCESS_KEY)

        current_dir = pathlib.Path(__file__).resolve().parent
        eq_dict_path = current_dir / '../EQ_Dict/json/aws_dict.json'
        with eq_dict_path.open(mode='r') as f:
            self.label_dict = json.loads(f.read())

    def build_label_dict(self, orig_preds: dict, true_labels: np.ndarray, threshold: float) -> dict:
        image_ids = list(orig_preds.keys())
        label_dict = {}

        for image_id in image_ids:
            local_class_index = true_labels[image_id]
            local_class_name = image_idx2class[local_class_index]

            if local_class_name not in label_dict:
                label_dict[local_class_name] = set()

            cloud_preds = orig_preds[image_id]['Labels']
            for item in cloud_preds:
                if item['Confidence'] >= threshold:
                    label_dict[local_class_name].add(item['Name'])

        for k in label_dict.keys():
            label_dict[k] = list(label_dict[k])

        return label_dict

    def test_accuracy(self, label_dict: dict, original_preds: dict, true_labels: np.ndarray, threshold: float) -> float:

        """
        Test the accuracy of the cloud platform, given local true label and label map.
        :param label_dict: The equivalence dictionary between cloud and local.
        :param original_preds: Original predictions of cloud platform.
        :param true_labels: Local true label class index.
        :param threshold: Confidence Threshold
        :return: Predicition accuracy.
        """

        image_ids = list(original_preds.keys())
        num_images = len(image_ids)
        success = 0

        for image_id in image_ids:
            cloud_prediction = original_preds[image_id]['Labels']
            local_class_index = true_labels[image_id]
            local_class_name = image_idx2class[local_class_index]
            cloud_class_names = label_dict[local_class_name]
            for item in cloud_prediction:
                if item['Confidence'] >= threshold:
                    if item['Name'] in cloud_class_names:
                        success += 1
                        break

        accuracy = success / num_images
        return accuracy

    def test_one_image(self, image_path):
        # check whether the image is totally made up with 0.0.0 pixels
        # if so, it means that this AE is a failure of CW2 attack,
        # and should be regarded as a failed AE, which will be remarked with 'fail' in the response.

        try:
            if mpimg.imread(image_path).max() == 0.:
                print('Bad CW2 AE detected. Recording this abnormal AE...')
                return {"BadCW2AE": "BadCW2AE"}
        except:
            print('Bad image format detected. Not an AE...')
            return {"BadCW2AE": "BadCW2AE"}

        with open(image_path, 'rb') as f:
            img = f.read()
        if self.task == 'classify':
            response = self.client.detect_labels(Image={'Bytes': img})
        elif self.task == 'gender':
            try:
                response = self.client.detect_faces(Image={'Bytes': img}, Attributes=['ALL', ])
            except:
                response = {'FaceDetails': 'Exception'}
                print('An exception occurs, possibly due to bad image format.')
        else:
            raise NotImplementedError('Unsupported task.')
        return response

    def analyze_one_image_classification(self, image, results):
        img_info = parse_ae_name(image)
        if img_info['true_label'] == img_info['adv_label']:
            return None
        true_label = img_info['true_label'].replace(' ', '_')
        adv_label = img_info['adv_label'].replace(' ', '_')
        predictions = results[img_info['id']]

        try:
            if 'BadCW2AE' in predictions.keys():
                print("Empty image generated by CW2 detected. Return NONE (this is not an AE).")
                return None
        except:
            pass

        labels = predictions['Labels']
        untargeted_succ = True
        targeted_succ = False
        for item in labels:
            name = item['Name']
            confidence = item['Confidence']
            if name in self.label_dict[true_label] and confidence > 50:
                untargeted_succ = False
            if name in self.label_dict[adv_label] and confidence > 50:
                targeted_succ = True
        return untargeted_succ, targeted_succ

    def analyze_one_image_gender(self, image, results):
        img_info = parse_ae_name(image)
        if img_info['true_label'] == img_info['adv_label']:
            return None
        predictions = results[img_info['id']]

        true_label = img_info['true_label']

        if 'BadCW2AE' in predictions.keys():
            print("Empty image generated by CW2 detected. Return NONE (this is not an AE).")
            return None
        else:
            try:
                label = predictions['FaceDetails'][0]['Gender']['Value'].lower()
            except:
                print('No face detected. Return NONE (this is not an AE).')
                return None
        label = label.lower()

        if true_label == 'female':
            is_female = True
            is_success = (label == 'male')
        else:
            is_female = False
            is_success = (label == 'female')
        return is_female, is_success