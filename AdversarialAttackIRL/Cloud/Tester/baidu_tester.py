import base64

import requests
import numpy as np
import matplotlib.image as mpimg
import matplotlib.pyplot as plt
import pickle
import json
import pathlib

from .tester_utils import parse_ae_name, fine_grained_match, coarse_grained_match, imagenet_tag_map, image_idx2class
from .tester import CloudTester

IMAGE_CLASSIFICATION_API_KEY = 'Your API key here'
IMAGE_CLASSIFICATION_SECRET_KEY = 'Your secret API key here'
IMAGE_CLASSIFICATION_REQUEST_HOST = 'https://aip.baidubce.com/rest/2.0/image-classify/v2/advanced_general'

GENDER_API_KEY = 'Your API key here'
GENDER_SECRET_KEY = 'Your secret API key here'
GENDER_REQUEST_HOST = 'https://aip.baidubce.com/rest/2.0/face/v3/detect'

ACCESS_TOKEN_REQUEST_HOST = 'https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&'


class BaiduCloudTester(CloudTester):
    def __init__(self, task: str):
        super(BaiduCloudTester, self).__init__(task)
        if self.task.lower() == 'classify':
            self.api_key = IMAGE_CLASSIFICATION_API_KEY
            self.secret_key = IMAGE_CLASSIFICATION_SECRET_KEY
            self.host_url = IMAGE_CLASSIFICATION_REQUEST_HOST
        elif self.task.lower() == 'gender':
            self.api_key = GENDER_API_KEY
            self.secret_key = GENDER_SECRET_KEY
            self.host_url = GENDER_REQUEST_HOST
        else:
            raise NotImplementedError('Only support classification & gender tasks.')
        access_token_request = ACCESS_TOKEN_REQUEST_HOST + 'client_id=' + self.api_key + '&client_secret=' + \
                               self.secret_key# + '&'
        self.access_token = requests.get(access_token_request).json()['access_token']

        if self.task.lower() == 'classify':
            current_path = pathlib.Path(__file__).resolve().parent
            label_dict_path = current_path / '../EQ_Dict/json/baidu_dict.json'
            with label_dict_path.open(mode='r', encoding="utf-8") as f:
                self.label_dict = json.loads(f.read())

    def test_one_image(self, image_path):
        # check whether the image is totally made up with 0.0.0 pixels
        # if so, it means that this AE is a failure of CW2 attack,
        # and should be regarded as a failed AE, which will be remarked with 'fail' in the response.
        try:
            if mpimg.imread(image_path).max() == 0.:
                print('Bad CW2 AE detected. Recording this abnormal AE...')
                return {"BadCW2AE": "BadCW2AE", "Faces": [{"Gender": "BadCW2AE"}]}
        except:
            print('Bad image format detected. Not an AE...')
            return {"BadCW2AE": "BadCW2AE", "Faces": [{"Gender": "BadCW2AE"}]}
        with open(image_path, 'rb') as f:
            img = base64.b64encode(f.read())
        if self.task.lower() != 'gender':
            params = {'image': img}
        else:
            params = {'image': img,
                      'image_type': 'BASE64',
                      'face_field': 'gender'}
        access_token = self.access_token
        request_url = self.host_url + '?access_token=' + access_token
        headers = {'content-type': 'application/x-www-form-urlencoded'}

        while True:
            try:
                response = requests.post(request_url, data=params, headers=headers)
                break
            except:
                print('Retries max, retrying...')

        return response.json()

    def analyze_one_image_classification(self, image, results):
        img_info = parse_ae_name(image)
        if img_info['true_label'] == img_info['adv_label']:
            return None
        predictions = results[img_info['id']]

        try:
            if 'BadCW2AE' in predictions.keys():
                print("Empty image generated by CW2 detected. Return NONE (this is not an AE).")
                return None
        except:
            pass

        if 'error_code' in predictions.keys():
            # print("Error code detected. Return NONE (this is not an AE).")
            return None

        if predictions['result_num'] == 0:
            print("No object has been detected in this image. Return NONE (this is not an AE).")
            return None

        untargeted_succ = True
        targeted_succ = False

        predictions = predictions['result']

        # # "tag-map" style matching
        # for item in predictions:
        #     # if item['score'] <= 0.5:
        #     #     continue
        #     if fine_grained_match(tag=item['keyword'], candidates=imagenet_tag_map[img_info['true_label']]):
        #         untargeted_succ = False
        #     if coarse_grained_match(tag=item['keyword'], candidates=imagenet_tag_map[img_info['adv_label']]):
        #         targeted_succ = True

        # "Label dictionary" style matching
        true_label = img_info['true_label'].replace(' ', '_')
        adv_label = img_info['adv_label'].replace(' ', '_')
        for item in predictions:
            if item['score'] <= 0.1:
                continue
            if item['keyword'] in self.label_dict[true_label] and item['score'] > 0.1:
                untargeted_succ = False
            if item['keyword'] in self.label_dict[adv_label] and item['score'] > 0.1:
                targeted_succ = True

        return untargeted_succ, targeted_succ

    def build_label_dict(self, orig_preds: dict, true_labels: np.ndarray, threshold: float) -> dict:
        threshold = threshold / 100
        image_ids = list(orig_preds.keys())
        label_dict = {}

        for image_id in image_ids:
            local_class_index = true_labels[image_id]
            local_class_name = image_idx2class[local_class_index]

            if local_class_name not in label_dict:
                label_dict[local_class_name] = set()

            cloud_preds = orig_preds[image_id]['result']
            for item in cloud_preds:
                if item['score'] >= threshold:
                    label_dict[local_class_name].add(item['keyword'])

        for k in label_dict.keys():
            label_dict[k] = list(label_dict[k])

        return label_dict

    def test_accuracy(self, label_dict: dict, original_preds: dict, true_labels: np.ndarray, threshold: float) -> float:

        """
        Test the accuracy of the cloud platform, given local true label and label map.
        :param label_dict: The equivalence dictionary between cloud and local.
        :param original_preds: Original predictions of cloud platform.
        :param true_labels: Local true label class index.
        :param threshold: Confidence Threshold
        :return: Predicition accuracy.
        """

        threshold /= 100.
        image_ids = list(original_preds.keys())
        num_images = len(image_ids)
        success = 0

        for image_id in image_ids:
            cloud_prediction = original_preds[image_id]['result']
            local_class_index = true_labels[image_id]
            local_class_name = image_idx2class[local_class_index]
            cloud_class_names = label_dict[local_class_name]
            for item in cloud_prediction:
                if item['score'] >= threshold:
                    if item['keyword'] in cloud_class_names:
                        success += 1
                        break

        accuracy = success / num_images
        return accuracy

    def analyze_one_image_gender(self, image, results):
        img_info = parse_ae_name(image)
        if img_info['true_label'] == img_info['adv_label']:
            return None
        predictions = results[img_info['id']]

        true_label = img_info['true_label']

        # print(predictions.keys())

        if 'Faces' in predictions.keys():
            print("Empty image generated by CW2 detected. Return NONE (this is not an AE).")
            return None
        else:
            try:
                label = predictions['result']['face_list'][0]['gender']['type']
            except:
                print('No face detected. Return NONE (this is not an AE).')
                return None
        label = label.lower()

        if true_label == 'female':
            is_female = True
            is_success = (label == 'male')
        else:
            is_female = False
            is_success = (label == 'female')
        return is_female, is_success


if __name__ == '__main__':
    tester = BaiduCloudTester('classify')
    from datetime import datetime

    t = datetime.now()
    result = tester.test_one_image('classify_sample.png')
    print('Time elapsed for 1 request = {}.'.format(datetime.now() - t))
    pass
